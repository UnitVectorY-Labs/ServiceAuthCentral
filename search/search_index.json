{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"ServiceAuthCentral","text":"<p>Simplify microservice security with ServiceAuthCentral: Centralized, open-source authorization in the cloud, minus the shared secrets.</p> <p>Here's what makes it stand out:</p> <ul> <li>Open Source: Freely available consisting of a centralized authorization server, management server, and web based management frontend.</li> <li>Server-to-Server Authentication: Targets solving server-to-server authentication for microservices using the client credentials OAuth 2.0 flow.</li> <li>Opinionated Centralized Authorization: Provides centralized capability for manage authorizations for microservices accessing eachother simplifying the process of authorization.</li> <li>Elimination of Shared Secrets: Advocates for the <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code> flow to reduce reliance on shared secrets. Utilizing cloud based solutions such as GCP service accounts can eliminate the need for shared secrets.</li> <li>Modular Cloud-Native Backend: Utilizes a module backend to support cloud native technologies for data persistence and utilizes cloud services such as KMS for JWT signing eliminating direct access to power secrets.</li> </ul>"},{"location":"contributorguide/","title":"Contributor Guide","text":"<p>ServiceAuthCentral is an open-source project licensed under Apache 2.0 and available on GitHub.  The project is maintained by UnitVectorY Labs and contributions are welcome.</p>"},{"location":"contributorguide/apireference/","title":"API Reference","text":"<p>The following is an API reference for the ServiceAuthCentral manage service and the user authentication used by serviceauthcentralweb for the administrative portal.  These APIs would not be used by microservices integrating with ServiceAuthCentral and represent the management plane of the system.</p> <p>Note</p> <p>For the API reference on the token server and how vend and validate tokens, see the Integration Guide - API Reference page.</p>"},{"location":"contributorguide/apireference/#post-v1token","title":"POST /v1/token","text":"<p>The <code>POST /v1/token</code> endpoint on the token API is primarily used for the client credentials and jwt bearer grant types as ServiceAuthCentral is primarily used for server-to-server authentication. However, to support the PKCE flow for the serviceauthcentralweb application, the token API also supports the authorization code grant type.  This flow is initiated by the serviceauthcentralweb application and then proceeds to the 3rd party application to authenticate the user completing a double OAuth 2.0 authorization process.</p>"},{"location":"contributorguide/apireference/#get-loginauthorize","title":"GET /login/authorize","text":"<p>The <code>GET /login/authorize</code> endpoint on the token API initiates the OAuth 2.0 authorization process using the PKCE (Proof Key for Code Exchange) flow from the serviceauthcentralweb application and then proceeds a flow for the 3rd party application to authenticate the user.</p> <p>Request Parameters:</p> <ul> <li><code>response_type</code> (String): Must be set to code. This indicates that an authorization code is being requested.</li> <li><code>client_id</code> (String): The client identifier issued to the client during the registration process.</li> <li><code>redirect_uri</code> (String): The URI to which the response will be sent. This must match one of the redirect URIs registered for the client.</li> <li><code>code_challenge</code> (String): A challenge derived from the code verifier by using one of the supported transformation methods.</li> <li><code>code_challenge_method</code> (String): Must be set to S256. This indicates the method used to derive the code challenge.</li> <li><code>state</code> (String): An opaque value used to maintain state between the request and the callback. This value should be used to prevent cross-site request forgery (CSRF) attacks.</li> </ul> <p>Response:</p> <p>On success, the endpoint will redirect the user to the 3rd party application for user authentication (such as Google or GitHub) using an OAuth 2.0 auth code flow.</p>"},{"location":"contributorguide/apireference/#get-logincallback","title":"GET /login/callback","text":"<p>The <code>GET /login/callback</code> endpoint on the token API handles the callback from the third-party authentication provider after the user has authenticated. This endpoint completes the OAuth 2.0 authorization process by exchanging the authorization code for user information and generating an authorization code for the client application.</p> <p>Request Parameters:</p> <p>sessionId (Cookie): The session identifier stored in a secure, HTTP-only cookie. code (String): The authorization code received from the third-party authentication provider. state (String): The state parameter received from the third-party authentication provider. This should match the state parameter sent in the initial authorization request.</p> <p>Response:</p> <p>On success, the endpoint will redirect the user back to serviceauthcentralweb completing the original PKCE flow which allows the user to then request a token from the token server that can be used to authenticate to the GraphQL management API.</p>"},{"location":"contributorguide/apireference/#post-graphql","title":"POST /graphql","text":"<p>The <code>POST /graphql</code> endpoint is the primary endpoint for interacting with the ServiceAuthCentral management API. This endpoint is a GraphQL endpoint that allows for querying and mutating data in the ServiceAuthCentral database.</p>"},{"location":"contributorguide/apireference/#query","title":"Query","text":"Field Argument Type Description clients ClientSummaryConnection   Get a list of clients.   first Int   The number of items to return starting after the cursor specified by 'after'. Used for forward pagination.   after String   The cursor after which to return the items. Used for forward pagination.   last Int   The number of items to return ending before the cursor specified by 'before'. Used for backward pagination.   before String   The cursor before which to return the items. Used for backward pagination.   client Client   Get a client by the clientId.   clientId ID!   The clientId of the client to retrieve.   authorization Authorization   Get an authorization by the id.   id ID!   The id of the authorization to retrieve."},{"location":"contributorguide/apireference/#mutation","title":"Mutation","text":"Field Argument Type Description addClient Client!   Add a new client.   clientId String!   The clientId of the new client. Must be globally unique.   description String!   The description of the client.   availableScopes [ClientScopeInput]   The list of scopes that this client is aware of and are available to be assigned to an authorized client.   addClientAvailableScope Response!   Add an additional available scope to an existing client that can be assigned to an authorized client.   clientId String!   The clientId of the client to add the available scope to.   availableScope ClientScopeInput!   The available scope to add to the client.   deleteClient Response!   Delete a client.   clientId String!   The clientId of the client to delete.   generateClientSecret1 ClientSecret!   Generates a new client secret for a client. This is one of two methods to generate a new client secret, differentiated by their names.   clientId String!   The clientId of the client to generate a new secret for.   generateClientSecret2 ClientSecret!   Generates a new client secret for a client. This is one of two methods to generate a new client secret, differentiated by their names.   clientId String!   The clientId of the client to generate a new secret for.   clearClientSecret1 ClientSecret!   Clears the client secret for a client. This is one of two methods to clear the client secret, differentiated by their names.   clientId String!   The clientId of the client to clear the secret for.   clearClientSecret2 ClientSecret!   Clears the client secret for a client. This is one of two methods to clear the client secret, differentiated by their names.   clientId String!   The clientId of the client to clear the secret for.   authorizeJwtBearer Response!   Add a jwt-bearer configuration to a client to use as an authorized user for the client.   clientId String!   The clientId of the client to authorize for use with jwt-bearer.   jwksUrl String!   The jwksUrl of the JWT bearer used to validate the JWT.   iss String!   The `iss` (issuer) claim that must be present in the JWT.   sub String!   The `sub` (subject) claim that must be present in the JWT.   aud String!   The `aud` (audience) claim that must be present in the JWT.   deauthorizeJwtBearer Response!   Deauthorize a jwt-bearer configuration from a client.   clientId String!   The clientId of the client to deauthorize for use with jwt-bearer.   id String!   The id of the JWT bearer configuration to deauthorize.   authorize Response!   Authorize a client to access another client with the authorization.   subject String!   The clientId of the service that will be granted access to the specified audience.   audience String!   The clientId of the service that is being accessed by the specified subject.   authorizedScopes [String]   The scopes that the subject is authorized to access on the audience. The scopes must be a subset of the audience's available scopes.   deauthorize Response!   Deauthorize a client from accessing another client.   subject String!   The clientId of the subject that will be deauthorized from the specified audience.   audience String!   The clientId of the audience that the subject will be deauthorized from.   authorizeAddScope Response!   Add an authorized scope to an existing authorization.   subject String!   The clientId of the subject that will be authorized to access the scope.   audience String!   The clientId of the audience that the subject will be authorized to access the scope on. The scope must be a subset of the audience's available scopes.   authorizedScope String!   The scope that the subject will be authorized to access on the audience.   authorizeRemoveScope Response!   Remove an authorized scope from an existing authorization.   subject String!   The clientId of the subject that will be deauthorized from accessing the scope.   audience String!   The clientId of the audience that the subject will be deauthorized from accessing the scope on.   authorizedScope String!   The scope that the subject will be deauthorized from accessing on the audience."},{"location":"contributorguide/apireference/#objects","title":"Objects","text":""},{"location":"contributorguide/apireference/#authorization","title":"Authorization","text":"<p>The authorization that allows a client to access another client.</p> Field Argument Type Description id ID!   The id of the authorization.   authorizationCreated String   The date the authorization was created. Returned in ISO-8601 format (yyyy-MM-dd\u2019T\u2019HH:mm:ssZ). The \u2018Z\u2019 indicates UTC, which is always used.   subject Client   The clientId of the subject that is authorized to access the audience.   audience Client   The clientId of the audience that the subject is authorized to access.   authorizedScopes [String]   The scopes that the subject is authorized to access on the audience."},{"location":"contributorguide/apireference/#client","title":"Client","text":"<p>The full representation of a client.</p> Field Argument Type Description clientId ID!   The clientId of the client.   clientCreated String   The date the client was created.   description String   The description of the client.   clientType String   The type of client.   clientSecret1Set Boolean   The indicator that the first client secret has been set for the client. The client secret is used to authenticate the client to the authorization server but is stored as a hashed value and cannot be retrieved after it is set.   clientSecret1Updated String   The time the first client secret was modified. Returned in ISO-8601 format (yyyy-MM-dd'T'HH:mm:ssZ). The 'Z' indicates UTC, which is always used.   clientSecret2Set Boolean   The indicator that the second client secret has been set for the client. The client secret is used to authenticate the client to the authorization server but is stored as a hashed value and cannot be retrieved after it is set.   clientSecret2Updated String   The time the second client secret was modified. Returned in ISO-8601 format (yyyy-MM-dd'T'HH:mm:ssZ). The 'Z' indicates UTC, which is always used.   authorizationsAsSubject [Authorization]   The list of authorizations where the client is the subject.   authorizationsAsAudience [Authorization]   The list of authorizations where the client is the audience.   availableScopes [ClientScope]   The list of available scopes that can be assigned to an authorized client.   jwtBearer [JwtBearer]   The list of jwt-bearer configurations that can be used to authorize the client.   managementPermissions ClientManagementCapabilities   The client management permissions for the client. These permissions are used to determine what actions can be taken on the client"},{"location":"contributorguide/apireference/#clientmanagementcapabilities","title":"ClientManagementCapabilities","text":"<p>The client management permissions for a client. These permissions are used to determine what actions can be taken on the client.</p> Field Argument Type Description canDeleteClient Boolean!   Indicates if the client can be deleted.   canAddClientSecret Boolean!   Indicates if the client secret can be added.   canDeleteClientSecret Boolean!   Indicates if the client secret can be deleted.   canAddClientAuthorization Boolean!   Indicates a jwt-bearer configuration can be added to the client.   canDeleteClientAuthorization Boolean!   Indicates a jwt-bearer configuration can be removed from the client.   canAddAvailableScope Boolean!   Indicates an available scope can be added to the client.   canAddAuthorization Boolean!   Indicates a client can be authorized to access this client.   canDeleteAuthorization Boolean!   Indicates a client can be deauthorized from accessing this client.   canAuthorizeAddScope Boolean!   Indicates a scope can be added.   canAuthorizeRemoveScope Boolean!   Indicates a scope can be removed."},{"location":"contributorguide/apireference/#clientscope","title":"ClientScope","text":"<p>The scope that can be assigned to an authorized client.</p> Field Argument Type Description scope ID!   The value for the scope.   description String   The description of the scope."},{"location":"contributorguide/apireference/#clientsecret","title":"ClientSecret","text":"<p>The client secret.</p> Field Argument Type Description clientSecret String   The generated client secret. This value is only returned once and cannot be retrieved again."},{"location":"contributorguide/apireference/#clientsummary","title":"ClientSummary","text":"<p>The abbreviated representation of a client.</p> Field Argument Type Description clientId ID!   The clientId of the client.   description String!   The description of the client."},{"location":"contributorguide/apireference/#clientsummaryconnection","title":"ClientSummaryConnection","text":"<p>A connection object for paginated ClientSummary results.</p> Field Argument Type Description edges [ClientSummaryEdge]   The list of edges, each containing a ClientSummary.   pageInfo PageInfo!   The page information used for pagination."},{"location":"contributorguide/apireference/#clientsummaryedge","title":"ClientSummaryEdge","text":"<p>An edge in a paginated list of ClientSummary objects.</p> Field Argument Type Description node ClientSummary   The ClientSummary node.   cursor String!   The cursor for use in pagination."},{"location":"contributorguide/apireference/#jwtbearer","title":"JwtBearer","text":"<p>The jwt-bearer configuration that can be used.</p> Field Argument Type Description id ID!   The id of the jwt-bearer configuration.   jwksUrl String   The jwksUrl of the JWT bearer used to validate the JWT.   iss String   The iss (issuer) claim that must be present in the JWT.   sub String   The sub (subject) claim that must be present in the JWT.   aud String   The aud (audience) claim that must be present in the JWT."},{"location":"contributorguide/apireference/#pageinfo","title":"PageInfo","text":"<p>Information about pagination in a connection.</p> Field Argument Type Description hasNextPage Boolean!   Indicates if there are more pages to fetch after the current one.   hasPreviousPage Boolean!   Indicates if there are more pages to fetch before the current one.   startCursor String   The cursor corresponding to the first node in the current page of results.   endCursor String   The cursor corresponding to the last node in the current page of results."},{"location":"contributorguide/apireference/#response","title":"Response","text":"<p>The response object for mutations.</p> Field Argument Type Description success Boolean!   The flag indicating if the operation was successful."},{"location":"contributorguide/apireference/#inputs","title":"Inputs","text":""},{"location":"contributorguide/apireference/#clientscopeinput","title":"ClientScopeInput","text":"<p>The input object for adding a new available scope to a client.</p> Field Type Description scope ID!   The value for the scope.   description String   The description of the scope."},{"location":"contributorguide/apireference/#scalars","title":"Scalars","text":""},{"location":"contributorguide/apireference/#boolean","title":"Boolean","text":"<p>The <code>Boolean</code> scalar type represents <code>true</code> or <code>false</code>.</p>"},{"location":"contributorguide/apireference/#id","title":"ID","text":"<p>The <code>ID</code> scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as <code>\"4\"</code>) or integer (such as <code>4</code>) input value will be accepted as an ID.</p>"},{"location":"contributorguide/apireference/#int","title":"Int","text":"<p>The <code>Int</code> scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.</p>"},{"location":"contributorguide/apireference/#string","title":"String","text":"<p>The <code>String</code> scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.</p>"},{"location":"contributorguide/architecture/","title":"Architecture","text":"<p>The architecture of ServiceAuthCentral takes an opinionated approach to eliminate secrets managed by both ServiceAuthCentral and other applications.  The goal of facilitating server-to-server authentication is to provide a secure and scalable solution that can be deployed in a variety of environments.  The architecture is designed to be modular and extendable to meet the needs of a variety of use cases.</p>"},{"location":"contributorguide/architecture/#key-components","title":"Key Components","text":"<p>A deployment of ServiceAuthCentral consists of the following components:</p> <ul> <li>Token Server (Container, REST API)</li> <li>Manage Server (Container, GraphQL API)</li> <li>Management Web Portal (Static Website)</li> <li>Database (Firestore)</li> <li>Key Management Service (GCP KMS)</li> </ul>"},{"location":"contributorguide/architecture/#elimination-of-secrets","title":"Elimination of Secrets","text":"<p>The motivation behind both the design and implementation of ServiceAuthCentral and the applications that utilize it is to eliminate the need for secrets to be managed by both ServiceAuthCentral and the applications that utilize it.</p> <p>Within ServiceAuthCentral this is accomplished through the following mechanisms:</p> <ul> <li>The management and signing of JWTs is done using a KMS key stored in GCP KMS.  This allows for the private key used for signing to be managed by GCP KMS and not stored or accessible by the application making it impossible for the application server or administrator to inadvertently expose the private key.</li> <li>Access to the required components including the database and KMS are done through Service Accounts without the need for secrets to be stored in the application configuration.</li> <li>In the case that a client does require a client secret, that is stored in Firestore has a hashed value with unique salts for each client.</li> </ul> <p>For clients utilizing ServiceAuthCentral the primary way of eliminating secrets is through the use of the JWT Bearer flow for authenticating to ServiceAuthCentral.  This is made possible by registering the JWKS, issuer, subject, and audience expected for a JWT for a specific client. This allows a variety of clients to authenticate to ServiceAuthCentral without the need for a client secret.</p> <p>For example, a workload running on GCP can use its service account to vend an identity token which can be used to authenticate to ServiceAuthCentral.  This allows for the workload to authenticate to ServiceAuthCentral without the need for a client secret and request a token for a service it is authorized to access. Putting these pieces together this allows for a system to be constructed where there are no persistent secrets are needed.</p>"},{"location":"contributorguide/modules/","title":"Modules","text":"<p>The primary use case for ServiceAuthCentral is to act as a backend for server-to-server authentication. ServiceAuthCentral has one primary repository that is divided into multiple Java modules that implement the primary functionality of the application. The implementation is a Java 17 Spring Boot 3 application that utilizes REST for the token endpoints and GraphQL for the management API.</p> <p>The main application is composed of Java modules which are described in the modules section of the documentation.  The main components being the token server, which is the data plane, and the manage server, which is the control plane.</p> <p>For the management aspect a web portal is provided with the serviceauthcentralweb.  This is implemented using Vue 3 with bootstrap for the interface and Appolo for interfacing with the GraphQL API.</p>"},{"location":"contributorguide/modules/#opentofu-terraform-modules","title":"OpenTofu / Terraform Modules","text":"<p>To aid in the deployment there are a number of different Tofu (Terraform) modules that aid in the deployment.</p> <ul> <li>serviceauthcentral-gcp-tofu - OpenTofu module for deploying a fully working ServiceAuthCentral deployment in GCP</li> </ul> <p>The functionality depends on a number of submodules.</p> <ul> <li>serviceauthcentral-token-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral token API to Cloud Run in GCP</li> <li>serviceauthcentral-manage-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral manage API to Cloud Run in GCP</li> <li>serviceauthcentral-kms-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral KMS Keys in GCP</li> <li>serviceauthcentral-firestore-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral Firestore Database</li> <li>serviceauthcentral-firestore-bootstrap-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral Firestore records needed to bootstrap an install</li> <li>serviceauthcentral-workload-identity-gcp-tofu - OpenTofu module for deploying ServiceAuthCentral Workload Identity Federation in GCP</li> </ul>"},{"location":"integrationguide/","title":"Integration Guide","text":"<p>ServiceAuthCentral provides an opinionated way to deploy an OAuth 2.0 server authorization server to facilitate server-to-server authentication and authorization between a diverse set of microservices.  The following guide will walk through the steps to integrate a <code>Client Service</code> which to request an access token from the <code>Token Server</code> to access a <code>Resource Service</code> which will then validate the token.  One key aspect of ServiceAuthCentral is it is intended that a microservice would use a single client id per microservice and use that as a resource server that other clients are able to access and as a client to access other resource servers allowing it to have a single identity within the system.</p>"},{"location":"integrationguide/apireference/","title":"API Reference","text":"<p>The following is an API reference for the ServiceAuthCentral token service and its use by <code>Client Services</code> and <code>Resource Services</code>. This is how your services will interact with the ServiceAuthCentral token service to request and validate access tokens.</p> <p>Note</p> <p>For the API reference on the manage server and how to manage clients and authorizations see the Contributor Guide - API Reference page.</p>"},{"location":"integrationguide/apireference/#post-v1token","title":"POST /v1/token","text":"<p>The <code>POST /v1/token</code> endpoint on the token server is the OAuth 2.0 token endpoint using for requesting access tokens that take the form of a JWT. The endpoint is used by <code>Client Services</code> to request access tokens for <code>Resource Services</code>.  The two flows supported are client credentials and the preferred jwt bearer flow.</p>"},{"location":"integrationguide/apireference/#client-credentials-flow","title":"Client Credentials Flow","text":"<p>Use this flow when you have a client secret (not preferred) to request an access token for your desired audience.</p> <pre><code>curl -X POST \"https://token.example.com/v1/token\" \\\n-H \"Content-Type: application/x-www-form-urlencoded\" \\\n--data-urlencode \"grant_type=client_credentials\" \\\n--data-urlencode \"client_id=your_client_id\" \\\n--data-urlencode \"client_secret=your_client_secret\" \\\n--data-urlencode \"audience=audience_to_access_client_id\"\n</code></pre>"},{"location":"integrationguide/apireference/#jwt-bearer-token-flow","title":"JWT Bearer Token Flow","text":"<p>Use this flow when you want to authenticate using a JWT from another service, such as a GCP service account, without a client secret. The audience parameter is still required.</p> <pre><code>curl -X POST \"https://token.example.com/v1/token\" \\\n-H \"Content-Type: application/x-www-form-urlencoded\" \\\n--data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer\" \\\n--data-urlencode \"assertion=eyJhbGF...7EEaTA\" \\\n--data-urlencode \"client_id=your_client_id\" \\\n--data-urlencode \"audience=audience_to_access_client_id\"\n</code></pre> <p>In both requests, the audience parameter is crucial as it specifies which service the token should grant access to. This parameter is checked against the authorization policies configured in ServiceAuthCentral to ensure the requesting client is authorized to access the specified service.</p>"},{"location":"integrationguide/apireference/#response","title":"Response","text":"<p>The response follows the standard OAuth 2.0 response format with the token being returned as a JWT.</p> <pre><code>{\n  \"access_token\": \"eyJhbGF...7EEaTA\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3600\n}\n</code></pre>"},{"location":"integrationguide/apireference/#get-well-knownjwksjson","title":"GET /.well-known/jwks.json","text":"<p>The <code>GET /.well-known/jwks.json</code> endpoint on the token server is used by <code>Resource Services</code> to obtain the public key used to validate the access tokens. The public key is used to verify the signature of the access token. This follows the OAuth 2.0 JSON Web Key (JWK) standard.</p>"},{"location":"integrationguide/apireference/#get-well-knownopenid-configuration","title":"GET /.well-known/openid-configuration","text":"<p>The <code>GET /.well-known/openid-configuration</code> endpoint on the token server is used by <code>Resource Services</code> to obtain the configuration information for the token server. This includes the token endpoint, the public key endpoint, and other configuration information.</p>"},{"location":"integrationguide/clientlibraries/","title":"Client Libraries","text":"<p>ServiceAuthCentral provides an implementation that is compatible with the OAuth 2.0 protocol.  Therefore existing code libraries may be compatible with the ServiceAuthCentral token service.  This is especially true for resource servers that are validating JWTs with the JWKS endpoint where standard JWT libraries can be easily used.</p> <p>For clients requesting tokens from the ServiceAuthCentral token service, the client libraries will need to be able to make HTTP requests to the token service. To simplify this process, ServiceAuthCentral provides a client library that can be used to request tokens from the token service.</p>"},{"location":"integrationguide/clientlibraries/#serviceauthcentral-java-client-library","title":"ServiceAuthCentral Java Client Library","text":"<p>The client library serviceauthcentral-client-java provides a streamlined way to request tokens from the ServiceAuthCentral token service.  The client library is designed to be used by client services that need to request tokens from the token service. It heavily leverages the builder design pattern to make it easy to construct the client and request tokens.</p>"},{"location":"integrationguide/clientlibraries/#jwt-bearer-token-flow-example-gcp-service-account","title":"JWT Bearer Token Flow Example (GCP Service Account)","text":"<p>The preferred method for requesting tokens from the ServiceAuthCentral token service is to use the JWT bearer token flow.  This flow utilizes GCP's service accounts to allow a workload running on GCP to use the JWT to authenticate to ServiceAuthCentral.  This flow is preferred as it does not require a client secret to be stored in the client service.</p> <p>Warning</p> <p>The serviceauthcentral-client-java is still under active development and a version is not available on Maven Central yet.</p> <p>When using <code>serviceauthcentral-client-java</code> the use of GCP with <code>GCPJwtCredentialsProvider</code> requires the optional dependency <code>google-auth-library-oauth2-http</code> to be included in the project.  This dependency is used to authenticate to GCP to request the JWT components to authenticate to ServiceAuthCentral.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auth&lt;/groupId&gt;\n    &lt;artifactId&gt;google-auth-library-oauth2-http&lt;/artifactId&gt;\n    &lt;version&gt;LATEST_VERSION&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>This example demonstrates the use of the decorator pattern to add caching to the client library. The <code>CachingSACClientDecorator</code> is used to cache the ServiceAuthCentral tokens to avoid unnecessary token requests and to handle token expiration automatically. The <code>GCPJwtCredentialsProvider</code> is used to provide the necessary JWT components to authenticate to ServiceAuthCentral, additional caching is not needed with this provider as it is already cached by the GCP libraries.</p> <pre><code>package example;\n\nimport com.google.auth.oauth2.GoogleCredentials;\nimport com.unitvectory.serviceauthcentral.client.CachingSACClientDecorator;\nimport com.unitvectory.serviceauthcentral.client.GCPJwtCredentialsProvider;\nimport com.unitvectory.serviceauthcentral.client.SACClient;\nimport com.unitvectory.serviceauthcentral.client.SACClientDefault;\nimport com.unitvectory.serviceauthcentral.client.TokenRequest;\nimport com.unitvectory.serviceauthcentral.client.TokenResponse;\n\n\npublic class ClientExample {\n\n    public static void main(String[] args) throws Exception {\n\n        String issuer = \"\"; // The issuer URL for ServiceAuthCentral\n        String clientId = \"\"; // The client ID of the client service\n        String jwtBearerAudience = \"\"; // The audience for the JWT bearer token\n\n        SACClient client = CachingSACClientDecorator.builder().client(SACClientDefault.builder()\n                .issuer(issuer)\n                .credentialsProvider(GCPJwtCredentialsProvider.builder()\n                        .googleCredentials(credentials)\n                        .clientId(clientId)\n                        .targetAudience(jwtBearerAudience)\n                        .build())\n                .build()).build();\n\n        // Request a token for the target service.\n        // Client must be authorized to access this audience.\n        String targetAudience = \"\"; // The target audience for the token\n        TokenResponse response = client.getToken(TokenRequest.builder().audience(\n                targetAudience)\n                .build());\n\n        // The access token can now be used to authenticate with the target service.\n        String accessToken = response.getAccessToken();\n        System.out.println(accessToken);\n    }\n}\n</code></pre> <p>The JWT Bearer must be configured in ServiceAuthCentral as a method to authorize a specific client, this requires specifying the following configuration values:</p> <ul> <li>JWKS URL: The URL to the JWKS endpoint ServiceAuthCentral will use to validate the JWT.</li> <li>Issuer: The issuer of the JWT in the JWT Bearer token. This will be matched with the JWKS and the <code>iss</code> claim in the JWT.</li> <li>Subject: The subject of the JWT in the JWT Bearer token. This is how the client is identified in the <code>sub</code> claim in the JWT.</li> <li>Audience: The audience of the JWT in the JWT Bearer token. This is flexible, but a good choice is to match the client ID within ServiceAuthCentral as that is the audience the token will be used to access.  This is the <code>aud</code> claim in the JWT.</li> </ul> <p>In the case that a GCP Service Account is used on GCP the token is requested by Google and signed  the configuration would look like:</p> <ul> <li>JWKS URL: <code>https://www.googleapis.com/oauth2/v3/certs</code></li> <li>Issuer: <code>https://accounts.google.com</code></li> <li>Subject: <code>{GOOGLE_SERVICE_ACCOUNT_CLIENT_ID}</code></li> <li>Audience: <code>{SERVICEAUTHCENTRAL_CLIENT_ID}</code></li> </ul> <p>In this case the issuer is Google and not the service account itself.  The subject of <code>{GOOGLE_SERVICE_ACCOUNT_CLIENT_ID}</code> is the client Id of the service account that takes for form of a numeric string like \"000000000000000000000\".</p>"},{"location":"integrationguide/clientlibraries/#local-jwt-bearer-token-example-gcp-service-account-json","title":"Local JWT Bearer Token Example (GCP Service Account JSON)","text":"<p>A JWT bearer token can be signed locally if a client has the private key.  This is not the preferred method as it requires the client to have the private key and the client secret. However, it is possible to use this method with a GCP service account given the JSON file. This is enabled by the fact Google provides a public JWKS endpoint for service accounts.</p> <p>This example demonstrates how to use the client library to request a token using the JWT bearer token flow and demonstrates how the decorator pattern can be optionally used to add caching to the client library. The <code>CachingSACClientDecorator</code> is used to cache the ServiceAuthCentral tokens to avoid unnecessary token requests and to handle token expiration automatically. Additionally the <code>CachingCredentialsProviderDecorator</code> is used to cache the construction of the local JWTs locally to avoid unnecessary construction of the JWTs.</p> <pre><code>package example;\n\nimport java.io.File;\n\nimport com.unitvectory.serviceauthcentral.client.CachingCredentialsProviderDecorator;\nimport com.unitvectory.serviceauthcentral.client.CachingSACClientDecorator;\nimport com.unitvectory.serviceauthcentral.client.LocalJwtCredentialsProvider;\nimport com.unitvectory.serviceauthcentral.client.SACClient;\nimport com.unitvectory.serviceauthcentral.client.SACClientDefault;\nimport com.unitvectory.serviceauthcentral.client.TokenRequest;\nimport com.unitvectory.serviceauthcentral.client.TokenResponse;\n\npublic class ClientExample {\n\n    public static void main(String[] args) {\n\n        String issuer = \"\"; // The issuer URL for ServiceAuthCentral\n        String clientId = \"\"; // The client ID of the client service\n        String gcpServiceAccountJsonPath = \"\"; // The path to the GCP service account JSON file\n        String jwtBearerAudience = \"\"; // The audience for the JWT bearer token\n\n        SACClient client = CachingSACClientDecorator.builder().client(SACClientDefault.builder()\n                .issuer(issuer)\n                .credentialsProvider(CachingCredentialsProviderDecorator.builder()\n                        .provider(LocalJwtCredentialsProvider.loadGCPServiceAccountFile(\n                                new File(gcpServiceAccountJsonPath))\n                                .clientId(clientId)\n                                .audience(jwtBearerAudience)\n                                .build())\n                        .build())\n                .build()).build();\n\n        // Request a token for the target service.\n        // Client must be authorized to access this audience.\n        String targetAudience = \"\"; // The target audience for the token\n        TokenResponse response = client.getToken(TokenRequest.builder().audience(\n                targetAudience)\n                .build());\n\n        // The access token can now be used to authenticate with the target service.\n        String accessToken = response.getAccessToken();\n    }\n}\n</code></pre> <p>The above example utilizes a helper method for specifically loading in the JSON file, but the <code>LocalJwtCredentialsProvider</code> can be used directly to load the necessary JWT components to sign a token to be used to request a token from the ServiceAuthCentral token service.</p> <pre><code>LocalJwtCredentialsProvider.builder()\n        .issuer(jwtBearerIssuer)\n        .keyId(jwtBearerKeyId)\n        .clientId(jwtBearerClientId)\n        .audience(jwtBearerAudience)\n        .privateKeyPem(jwtBearerPrivateKey)\n        .build();\n</code></pre> <p>In the case that a GCP Service Account is directly used for this example with a GCP Service Account the configuration would look like:</p> <ul> <li>JWKS URL: <code>https://www.googleapis.com/service_accounts/v1/jwk/{SERVICE_ACCOUNT}@{PROJECT}.iam.gserviceaccount.com</code></li> <li>Issuer: <code>{SERVICE_ACCOUNT}@{PROJECT}.iam.gserviceaccount.com</code></li> <li>Subject: <code>{SERVICE_ACCOUNT}@{PROJECT}.iam.gserviceaccount.com</code></li> <li>Audience: <code>{SERVICEAUTHCENTRAL_CLIENT_ID}</code></li> </ul> <p>Since the private key is used to identify the service account directly the issuer and subject are identical.  The JWKS url is the endpoint that Google provides to get the public key for the service account. As mentioned earlier, the audience claim should match the client ID in ServiceAuthCentral that the token will be used to access.</p>"},{"location":"integrationguide/clientlibraries/#client-credentials-example","title":"Client Credentials Example","text":"<p>While discouraged, the client credentials flow can be used to request a token from the ServiceAuthCentral token service.  This flow requires the client ID and client secret to be provided in the request. ServiceAuthCentral's philosophy is to avoid storing client secrets in client services, so this flow is discouraged. However, it is possible to use this flow with the client library.</p> <p>This example demonstrates how to use the client library to request a token using the client credentials flow and demonstrates how the decorator pattern can be optionally used to add caching to the client library.</p> <pre><code>package example;\n\nimport com.unitvectory.serviceauthcentral.client.CachingCredentialsProviderDecorator;\nimport com.unitvectory.serviceauthcentral.client.CachingSACClientDecorator;\nimport com.unitvectory.serviceauthcentral.client.SACClient;\nimport com.unitvectory.serviceauthcentral.client.SACClientDefault;\nimport com.unitvectory.serviceauthcentral.client.StaticClientCredentialsProvider;\nimport com.unitvectory.serviceauthcentral.client.TokenRequest;\nimport com.unitvectory.serviceauthcentral.client.TokenResponse;\n\npublic class ClientExample {\n\n    public static void main(String[] args) {\n\n        String issuer = \"\"; // The issuer URL for ServiceAuthCentral\n        String clientId = \"\"; // The client ID of the client service\n        String clientSecret = \"\"; // The client secret of the client service\n\n        // Construct the SAC client, include caching to avoid unnecessary token\n        // requests and to handle token expiration automatically.\n        SACClient client = CachingSACClientDecorator.builder().client(SACClientDefault.builder()\n                .issuer(issuer)\n                .credentialsProvider(CachingCredentialsProviderDecorator.builder()\n                        .provider(StaticClientCredentialsProvider.builder()\n                                .clientId(clientId)\n                                .clientSecret(clientSecret)\n                                .build())\n                        .build())\n                .build()).build();\n\n        // Request a token for the target service.\n        // Client must be authorized to access this audience.\n        String targetAudience = \"\"; // The target audience for the token\n        TokenResponse response = client.getToken(TokenRequest.builder().audience(\n                targetAudience)\n                .build());\n\n        // The access token can now be used to authenticate with the target service.\n        String accessToken = response.getAccessToken();\n    }\n}\n</code></pre>"},{"location":"integrationguide/gcpworkloadidentity/","title":"GCP Workload Identity","text":"<p>One of the benefits of using Google Cloud Platform (GCP) is the ability to use Workload Identity Federation to securely access Google Cloud services with external credentials through an OIDC-compliant token service.  This allows you to use the ServiceAuthCentral token service to request access tokens for Google Cloud services using a Google Service Account.</p> <p>With ServiceAuthCentral acting as an authorization server requiring each audience to be authorized, including the audience for the GCP Workload Identity Pool.</p>"},{"location":"integrationguide/gcpworkloadidentity/#configuring-gcp-workload-identity","title":"Configuring GCP Workload Identity","text":"<p>The primary prerequisite for using GCP Workload Identity is to have a Google Cloud project with the Workload Identity Pool and Provider configured.  This can be done through the Google Cloud Console or gcloud, but for the example here it is assumed that serviceauthcentral-workload-identity-gcp-tofu was used to configure things specifically for ServiceAuthCentral.</p> <p>The configuration of the Workload Identity is based on the issuer of ServiceAuthCentral which Google will use to validate the tokens.</p> <p>The key output of this step will be the principal for the Workload Identity Pool, which will include the following variables:</p> <ul> <li><code>PROJECT_NUMBER</code></li> <li><code>POOL_NAME</code></li> <li><code>POOL_PROVIDER</code></li> </ul> <p>The key output here is what will be used as the audience within ServiceAuthCentral.</p> <p><code>//iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/providers/{POOL_PROVIDER}</code></p>"},{"location":"integrationguide/gcpworkloadidentity/#serviceauthcentral-client-for-gcp-workload-identity","title":"ServiceAuthCentral Client for GCP Workload Identity","text":"<p>With ServiceAuthCentral being used as an authorization server the client that is wanting to access GCP services will need to be authorized to access the Workload Identity Pool both within ServiceAuthCentral and within GCP.</p> <p>The audience inside of ServiceAuthCentral can be automatically configured as part of the bootstrap process with serviceauthcentral-firestore-bootstrap-gcp-tofu. This creates a client with the audience of: <code>//iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/providers/{POOL_PROVIDER}</code> This is the same audience that is used to request the token from the GCP Workload Identity Pool which is an intentional design decision.</p> <p>Clients can then be authorized in ServiceAuthCentral to access this client which will allow for JWTs to be vended with the correct audience.  The <code>SAC_CLIENT_ID</code> is needed to request the token.  The example below is using a client_secret:</p> <pre><code>curl --request POST \\\n  --url 'https://issuer.example.com/v1/token' \\\n  --header 'Content-Type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=client_credentials' \\\n  --data 'client_id={SAC_CLIENT_ID}' \\\n  --data 'client_secret={SAC_CLIENT_SECRET}' \\\n  --data 'audience=//iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/providers/{POOL_PROVIDER}'\n</code></pre> <p>However, the principal behind ServiceAuthCentral is avoiding shared secrets therefore the <code>urn:ietf:params:oauth:grant-type:jwt-bearer</code> flow would be more ideal.</p> <pre><code>curl --request POST \\\n  --url 'https://issuer.example.com/v1/token' \\\n  --header 'Content-Type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer' \\\n  --data 'client_id={SAC_CLIENT_ID}' \\\n  --data 'assertion={SAC_AUTHORIZED_JWT}' \\\n  --data 'audience=//iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/providers/{POOL_PROVIDER}'\n</code></pre> <p>This will return the token that can be used to access the GCP Workload Identity Pool.</p> <pre><code>{\n  \"access_token\" : \"{SERVICEAUTHCENTRAL_JWT}\",\n  \"token_type\" : \"Bearer\",\n  \"expires_in\" : 3600\n}\n</code></pre>"},{"location":"integrationguide/gcpworkloadidentity/#requesting-gcp-access-token","title":"Requesting GCP Access Token","text":"<p>To request a token, make a <code>POST</code> request to <code>https://sts.googleapis.com/v1/token</code> with the following parameters in the <code>application/x-www-form-urlencoded</code> format to request:</p> <pre><code>curl --request POST \\\n  --url 'https://sts.googleapis.com/v1/token' \\\n  --header 'Content-Type: application/x-www-form-urlencoded' \\\n  --data 'grant_type=urn:ietf:params:oauth:grant-type:token-exchange' \\\n  --data 'requested_token_type=urn:ietf:params:oauth:token-type:access_token' \\\n  --data 'scope=https://www.googleapis.com/auth/cloud-platform' \\\n  --data 'audience=//iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/providers/{POOL_PROVIDER}' \\\n  --data 'subject_token_type=urn:ietf:params:oauth:token-type:jwt' \\\n  --data 'subject_token={SERVICEAUTHCENTRAL_JWT}' \\\n</code></pre> <pre><code>{\n  \"access_token\": \"{GCP_WIF_ACCESS_TOKEN}\",\n  \"issued_token_type\": \"urn:ietf:params:oauth:token-type:access_token\",\n  \"token_type\": \"Bearer\",\n  \"expires_in\": 3599\n}\n</code></pre> <p>This token can then be used to access GCP services that are authorized for the correct principal. Most Service Accounts are authorized with email addresses, but the principal for the Workload Identity Pool is in the format of:</p> <p><code>principal://iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/subject/{SAC_CLIENT_ID}</code></p> <p>The key here is that the ServiceAuthCentral client id which was authorized is used to identify the principal allowing access to the GCP services to be properly scoped to a specific client.</p> <p>Granting access to GCP services to this principal directly is generally speaking the preferred method, but it is also possible to impersonate a service account as explained in the next section.</p>"},{"location":"integrationguide/gcpworkloadidentity/#impersonating-a-service-account","title":"Impersonating a Service Account","text":"<p>To impersonate a GCP Service account some additional setup is required.  A service account must be created and then the <code>roles/iam.workloadIdentityUser</code> / \"Workload Identity User\" role must be granted to the same principal referenced before of <code>principal://iam.googleapis.com/projects/{PROJECT_NUMBER}/locations/global/workloadIdentityPools/{POOL_NAME}/subject/{SAC_CLIENT_ID}</code> which will allow the principal to impersonate the service account.</p> <p>The service account must also be granted the necessary roles to access the GCP services that are needed.</p> <p>Then the previous access token can be used to impersonate the service account:</p> <pre><code>curl -X POST \\\n  -H \"Authorization: Bearer {GCP_WIF_ACCESS_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"scope\": [\"https://www.googleapis.com/auth/cloud-platform\"],\"lifetime\": \"3600s\"}' \\\n  \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{SERVICE_ACCOUNT_EMAIL}:generateAccessToken\"\n</code></pre> <p>This returns the access token for the service account which can then be used to access GCP services:</p> <pre><code>{\n  \"accessToken\": \"{SERVICE_ACCOUNT_ACCESS_TOKEN}\",\n  \"expireTime\": \"2XXX-XX-XXTXX:XX:XXZ\"\n}\n</code></pre> <p>Alternatively if an identity token for the GCP service account is needed it can be requested with a specific audience:</p> <pre><code>curl -X POST \\\n  -H \"Authorization: Bearer {GCP_WIF_ACCESS_TOKEN}\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{ \"audience\": \"https://myaudience.example.com\", \"includeEmail\": true}' \\\n  \"https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/{SERVICE_ACCOUNT_EMAIL}:generateIdToken\"\n</code></pre> <p>This returns the identity token for the service account:</p> <pre><code>{\n  \"token\": \"{SERVICE_ACCOUNT_ID_TOKEN}\"\n}\n</code></pre>"},{"location":"integrationguide/gettingstarted/","title":"Getting Started","text":"<p>Once the ServiceAuthCentral token service is deployed, you can start integrating your services with it.  This guide will walk through the steps to integrate a <code>Client Service</code> which to request an access token from the <code>Token Server</code> to access a <code>Resource Service</code> which will then validate the token.</p> <pre><code>sequenceDiagram\n    Client Service-&gt;&gt;+Token Server: POST /v1/token&lt;br/&gt;(client credentials or jwt-bearer)\n    Token Server -&gt;&gt; Token Server: Validate Credentials&lt;br/&gt;and Authorize Audience\n    Token Server--&gt;&gt;-Client Service: 200 OK&lt;br/&gt;(Access Token - JWT)\n\n    Client Service-&gt;&gt;+Resource Service: GET /resource&lt;br/&gt;(Access Token - JWT)\n\n    Resource Service-&gt;&gt;+Token Server: GET /.well-known/jwks.json&lt;br/&gt;(JWKS Retrieval)\n    Token Server--&gt;&gt;-Resource Service: 200 OK&lt;br/&gt;(JWKS)\n\n    Resource Service -&gt;&gt; Resource Service: Validate JWT&lt;br/&gt;Signature and Audience\n\n    Resource Service--&gt;&gt;-Client Service: 200 OK&lt;br/&gt;(Resource Data)</code></pre>"},{"location":"integrationguide/gettingstarted/#client-service","title":"Client Service","text":"<p>A Client Service is responsible for requesting an access token from the Token Server to access a Resource Service. It must be able to send HTTP requests to both the Token Server (to obtain the access token) and the Resource Service (to access protected resources using that token).</p> <p>In ServiceAuthCentral, each client is assigned a specific identity (clientId) and authorized to access resource services based on the audience. When the Client Service requests an access token using the JWT-bearer flow (or the client credentials flow if necessary), ServiceAuthCentral ensures both authentication and authorization for the requested audience and scopes. The issued access token is a JWT containing claims that define the authorized actions for the client. By eliminating shared secrets, each client retains its own identity, ensuring secure interactions without reliance on traditional credential mechanisms.</p>"},{"location":"integrationguide/gettingstarted/#token-server-serviceauthcentral","title":"Token Server (ServiceAuthCentral)","text":"<p>ServiceAuthCentral acts as a robust authorization server, going beyond basic OAuth 2.0 functionality. It centralizes authorization by verifying both the client\u2019s identity and its permissions to access the requested audience and scopes. Tokens are only issued if the client is explicitly authorized, enforcing strict control over access. This emphasis on authorization\u2014rather than just authentication\u2014sets ServiceAuthCentral apart from typical OAuth servers.</p> <p>A unique aspect of ServiceAuthCentral is that every clientId can function both as a client and a resource server, promoting a unified identity across the infrastructure. With a preference for JWT-bearer authentication and the avoidance of shared secrets, ServiceAuthCentral provides a secure, streamlined access control solution between various services.</p>"},{"location":"integrationguide/gettingstarted/#resource-service","title":"Resource Service","text":"<p>A Resource Service is a protected endpoint that validates and authorizes incoming requests using JWT access tokens issued by ServiceAuthCentral. The service validates the JWT\u2019s signature using the public keys provided by the ServiceAuthCentral JWKS endpoint (/.well-known/jwks.json).</p> <p>Crucially, the Resource Service verifies that the client is both authenticated and authorized for the requested audience and scopes. Since ServiceAuthCentral only issues tokens to clients authorized for specific audiences, this process ensures secure, scope-limited access. With each client authenticated via the JWT-bearer flow and no need for shared secrets, the Resource Service can confidently verify the client\u2019s identity and authorized scope, providing seamless access control within the ServiceAuthCentral ecosystem.</p>"},{"location":"modules/","title":"Modules","text":"<p>ServiceAuthCentral is built as a modular application using Java and Maven with Spring Boot 3. There are a number of different modules that comprise the application and are described in this section. This design allows for modules to be swapped out at runtime to provide different implementations of the same functionality. This is useful for testing and development as well as for production deployments where different implementations may be required.</p> <ul> <li>Token Server</li> <li>Manage Server</li> <li>Data Model - Index</li> <li>Data Model - Firestore</li> <li>Data Model - In-memory</li> <li>Sign - Index</li> <li>Sign - GCP</li> <li>Sign - Local</li> <li>User - Index</li> <li>User - GitHub</li> <li>User - Google</li> <li>Verify - Index</li> <li>Verify - Auth0</li> <li>Utility</li> </ul>"},{"location":"modules/manageserver/","title":"Manage Server","text":"<p>The manage server provides the control plane for ServiceAuthCentral in the form of a GraphQL endpoint for managing the authorization server.</p>"},{"location":"modules/manageserver/#overview","title":"Overview","text":"<p>The manage server provides a GraphQL endpoint providing the control plane for ServiceAuthCentral. This includes the ability to manage authorizations and clients.</p> <pre><code>flowchart LR\n    subgraph SAC[ServiceAuthCentral]\n        ManageServer[Manage Server]\n\n        subgraph DataModel[Data Model]\n            authorizations[(authorizations)]\n            clients[(clients)]\n        end\n\n        ManageServer -- Get/Update/Delete\\nAuthorization--&gt; authorizations\n        ManageServer -- Get/Update/Delete\\nClient--&gt; clients\n    end\n\n    ServiceAuthCentralWeb[ServiceAuthCentral\\nWeb Interface]\n\n    ServiceAuthCentralWeb -- GraphQL --&gt; ManageServer</code></pre>"},{"location":"modules/manageserver/#build-manage-server-docker-image","title":"Build Manage Server Docker Image","text":"<p>Both the manage and token service are compiled from the same repository git repository and Dockerfile. The command to build the manage server requires the correct build-arg to be passed in to generate the docker container for the manage server components.</p> <pre><code>docker build -f Dockerfile --build-arg MAVEN_PROFILE=server-manage -t serviceauthcentral/server-manage .\n</code></pre>"},{"location":"modules/manageserver/#run-manage-server-using-docker","title":"Run Manage Server Using Docker","text":"<p>The Docker image for the manage server is configured using environment variables.</p> <p>Tip</p> <p>These properties are required to be identical between the manage and token server deployment.</p> Property Required Description spring.profiles.active Yes A corresponding profile must be selected for Data Model sac.issuer Yes The JWT issuer url. Typically the domain name of the token server. sac.cors.origins Yes CORS origins for web based logins. This is the domain name ServiceAuthCentral Web is deployed to."},{"location":"modules/manageserver/#authentication-and-authorization","title":"Authentication and Authorization","text":"<p>While the primary purpose of ServiceAuthCentral is server-to-server authentication with OAuth 2.0, this management API needs a mechanism to vend access tokens to the web based front end specifically serviceauthcentralweb. To support this server-token supports a PKCE login flow.</p> <p>The tokens that are able to call the management API have the audience value which has the value of the issuer. Meaning in the JWT the issuer and audience have the same value.</p>"},{"location":"modules/tokenserver/","title":"Token Server","text":"<p>The token server provides the data plane for ServiceAuthCentral in the form of the token endpoint used to vend the JWT access tokens.</p>"},{"location":"modules/tokenserver/#overview","title":"Overview","text":"<p>The token server provides two major functions. First is providing the JWKS endpoint to resource servers. The public keys are retrieved from the specific implementation of the <code>sign</code> module. And the primary function is providing the OAuth 2.0 endpoint for clients to request access tokens which are returned in the form of JWTs.</p> <pre><code>flowchart LR\n    subgraph SAC[ServiceAuthCentral]\n        TokenServer[Token Server]\n\n        subgraph Sign\n            PrivateKey[Private Key]\n            PublicKey[Public Key]\n        end\n\n        subgraph DataModel[Data Model]\n            authorizations[(authorizations)]\n            clients[(clients)]\n        end\n\n        TokenServer -- Get Authorization--&gt; authorizations\n        TokenServer -- Get Client--&gt; clients\n\n        TokenServer -- Get Public Key--&gt; PublicKey\n        TokenServer -- Sign JWT --&gt; PrivateKey\n    end\n\n    ResourceServer[Resource Server]\n    ResourceServer -- GET JWKS --&gt; TokenServer\n\n    Client -- Request Token --&gt; TokenServer\n\n    Client -. API Call.-&gt; ResourceServer</code></pre>"},{"location":"modules/tokenserver/#build-token-server-docker-image","title":"Build Token Server Docker Image","text":"<p>Both the manage and token service are compiled from the same repository git repository and Dockerfile. The command to build the token server requires the correct build-arg to be passed in to generate the docker container for the token server components.</p> <pre><code>docker build -f Dockerfile --build-arg MAVEN_PROFILE=server-token -t serviceauthcentral/server-token .\n</code></pre>"},{"location":"modules/tokenserver/#run-token-server-using-docker","title":"Run Token Server Using Docker","text":"<p>The Docker image for the token server is configured using environment variables.</p> <p>Note</p> <p>These properties are required to be identical between the manage and token server deployment.</p> Property Required Description spring.profiles.active Yes A corresponding profile must be selected for each of Data Model and Sign. These are set as a comma separated list. sac.user.redirecturi Yes The redirect URI for serviceauthcentralweb; multiple values can be specified separated by commas sac.issuer Yes The JWT issuer url. Typically the domain name of the token server. sac.cors.origins Yes CORS origins for web based logins. This is the domain name ServiceAuthCentral Web is deployed to. sac.server.token.external.cache.seconds No Number of seconds external JWKS is cached. Default is 3600 seconds."},{"location":"modules/util/","title":"Util","text":"<p>The util module provides utility classes and methods that are used throughout the project.</p>"},{"location":"modules/util/#exceptions","title":"Exceptions","text":"<p>The following exceptions are used throughout the project and are defined in the util module:</p> <ul> <li><code>BadRequestException</code></li> <li><code>ConflictException</code></li> <li><code>ForbiddenException</code></li> <li><code>InternalServerErrorException</code></li> <li><code>NotFoundException</code></li> <li><code>UnauthorizedException</code></li> </ul>"},{"location":"modules/util/#utility-classes","title":"Utility Classes","text":"<p>The following utility classes are provided:</p> <ul> <li><code>HashingUtil</code> - Provides methods for sha256 hashing</li> </ul>"},{"location":"modules/datamodel/","title":"Data Model","text":"<p>The data model module provides the interfaces for accessing the repositories and data so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/datamodel/#repository-interfaces","title":"Repository Interfaces","text":"<p>The following interfaces are implemented to provide data persistence.</p> <ul> <li><code>AuthorizationRepository</code>: Manage client authorizations; which clients are authorized to access others for centralized authorization model</li> <li><code>ClientRepository</code>: Manage clients; catalog of all of the registered clients.</li> <li><code>JwkCacheRepository</code>: Manage JWK cache; improves performance and availability for external authentications.</li> <li><code>LoginCodeRepository</code>: Manage login codes; the authorization code repository to allow users to log in</li> <li><code>LoginStateRepository</code>: Manage login state; the session needed to complete the OAuth user login flow</li> </ul> <p>A flexible deployment is supported by allowing different underlying database technologies based on the desired deployment mechanism.</p>"},{"location":"modules/datamodel/#repository-implementations","title":"Repository Implementations","text":"<p>There are multiple data model implementations that are available. Exactly one module must be enabled at runtime.</p> <p>Note</p> <p>Each module implementation will have additional properties that are required to be set for it to work correctly when it is enabled, typically through envirionment variables.</p> <ul> <li>Data Model - Firestore: Firestore implementation for the repository interfaces</li> <li>Data Model - Valkey: Valkey implementation for the repository interfaces</li> <li>Data Model - Memory: In-memory implementation for the repository interfaces used for testing and development</li> </ul>"},{"location":"modules/datamodel/firestore/","title":"Data Model - Firestore","text":"<p>The data model firestore module provides a GCP Firestore implementation of the the data model interfaces so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/datamodel/firestore/#collections","title":"Collections","text":"<p>The following collections are used by the firestore data store:</p> <pre><code>flowchart TD\n    authorizations[(authorizations)]\n    clients[(clients)]\n    keys[(keys)]\n    loginCodes[(loginCodes)]\n    loginStates[(loginStates)]</code></pre>"},{"location":"modules/datamodel/firestore/#spring-boot-profile","title":"Spring Boot Profile","text":"<p>Spring Boot 3's dependency injection is used to initialize the relevant Beans for interacting with Firestore. This is accomplished through profiles.</p> <p>The <code>datamodel-firestore</code> profile is enabled to utilize GCP Firestore.</p>"},{"location":"modules/datamodel/firestore/#configuration","title":"Configuration","text":"<p>The following configuration attributes:</p> Property Required Description google.cloud.project Yes GCP Project name sac.datamodel.firestore.database No (default: '(default)') Firestore database name sac.datamodel.firestore.collection.authorizations No (default: 'authorizations') Firestore collection name sac.datamodel.firestore.collection.clients No (default: 'clients') Firestore collection name sac.datamodel.firestore.collection.keys No (default: 'keys') Firestore collection name sac.datamodel.firestore.collection.logincodes No (default: 'loginCodes') Firestore collection name sac.datamodel.firestore.collection.loginstates No (default: 'loginStates') Firestore collection name"},{"location":"modules/datamodel/memory/","title":"Data Model - Memory","text":"<p>The data model memory module provides an in memory implementation of the the data model interfaces so that the underlying implementation can be swapped out as a runtime dependency.</p> <p>This module is not practical for a production deployment but is useful for testing and development.</p>"},{"location":"modules/datamodel/memory/#spring-boot-profile","title":"Spring Boot Profile","text":"<p>Spring Boot 3's dependency injection is used to initialize the relevant Beans for using memory data model. This is accomplished through profiles.</p> <p>The <code>datamodel-memory</code> profile is enabled to utilize the memory data model.</p>"},{"location":"modules/datamodel/valkey/","title":"Data Model - Valkey","text":"<p>The data model Valkey module provides a Valkey implementation of the data model interfaces so that the underlying implementation can be swapped out as a runtime dependency.</p> <p>Valkey is an open source, high-performance key/value datastore that is compatible with Redis. This module uses Spring Data Redis with the Lettuce client to connect to Valkey.</p>"},{"location":"modules/datamodel/valkey/#data-storage","title":"Data Storage","text":"<p>Data is stored in Valkey using Hash structures with the following key prefixes:</p> <ul> <li><code>sac:client:{clientId}</code> - Client records</li> <li><code>sac:clients</code> - Sorted set index for client pagination</li> <li><code>sac:auth:{documentId}</code> - Authorization records</li> <li><code>sac:auth:subject:{subject}</code> - Set index of authorizations by subject</li> <li><code>sac:auth:audience:{audience}</code> - Set index of authorizations by audience</li> <li><code>sac:auth:lookup:{subjectHash}:{audienceHash}</code> - Lookup key for authorization by subject and audience</li> <li><code>sac:loginstate:{sessionId}</code> - Login state records (with TTL)</li> <li><code>sac:logincode:{code}</code> - Login code records (with TTL)</li> <li><code>sac:jwk:{url}:{kid}</code> - Cached JWK records (with TTL)</li> <li><code>sac:jwk:url:{url}</code> - Set index of JWK kids by URL</li> </ul>"},{"location":"modules/datamodel/valkey/#spring-boot-profile","title":"Spring Boot Profile","text":"<p>Spring Boot 3's dependency injection is used to initialize the relevant Beans for interacting with Valkey. This is accomplished through profiles.</p> <p>The <code>datamodel-valkey</code> profile is enabled to utilize Valkey.</p>"},{"location":"modules/datamodel/valkey/#configuration","title":"Configuration","text":"<p>The following configuration attributes are available:</p> Property Required Description spring.data.redis.host Yes Valkey server hostname spring.data.redis.port No (default: 6379) Valkey server port spring.data.redis.password No Valkey server password spring.data.redis.ssl.enabled No (default: false) Enable SSL/TLS"},{"location":"modules/sign/","title":"Sign","text":"<p>The sign module provides the interfaces for accessing and using the public keyes used for signing JWTs so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/sign/#sign-implementations","title":"Sign Implementations","text":"<p>There are multiple data model implementations that are available. Exactly one module must be enabled at runtime.</p> <p>Note</p> <p>Each module implementation will have additional environment variables that are required for it to work correctly when it is enabled.</p> <ul> <li>Sign - GCP: Utilizing GCP's KMS service for managing and signing JWTs</li> <li>Sign - Local: Utilize a local RSA key for signing JWTs</li> </ul>"},{"location":"modules/sign/gcp/","title":"Sign - GCP","text":"<p>The sign gcp module provides a GCP KMS implementation of the sign interface so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/sign/gcp/#overview","title":"Overview","text":"<p>The benefit of using this module when running on GCP is that the KMS service is responsible for protecting the private key.  The private key is therefore able to be used for signing without being exposed to the application.</p> <pre><code>flowchart LR\n    subgraph gcpproject[GCP Project]\n        ServiceAuthCentral\n\n        subgraph KMS\n            PrivateKey[Private Key]\n            PublicKey[Public Key]\n        end\n\n        DataModel[(Data Model)]\n\n        ServiceAuthCentral -- Get Client/Authorization--&gt; DataModel\n\n        ServiceAuthCentral -- Get Public Key--&gt; PublicKey\n        ServiceAuthCentral -- Sign --&gt; PrivateKey\n    end\n\n    ResourceServer[Resource Server]\n    ResourceServer -- JWKS --&gt; ServiceAuthCentral\n\n    Client -- Request Token --&gt; ServiceAuthCentral</code></pre>"},{"location":"modules/sign/gcp/#gcp-configuration","title":"GCP Configuration","text":"<p>This implementation only supports the <code>RSA_SIGN_PKCS1_2048_SHA256</code> signing algorithm. Therefore the GCP KMS key must have a purpose of <code>Asymmetric sign</code> and an algorithm of <code>2048 bit RSA - PKCS#1 v1.5 padding - SHA256 Digest</code>.</p>"},{"location":"modules/sign/gcp/#configuration","title":"Configuration","text":"<p>This module is enabled by setting the <code>SPRING_PROFILES_ACTIVE</code> to include the profile <code>sign-gcp</code>.</p> <p>The following properties are used by the GCP KMS module:</p> Property Required Description google.cloud.project Yes GCP Project name sac.sign.gcp.key.ring Yes KMS Key Ring Name sac.sign.gcp.key.name Yes KMS Key Name sac.sign.gcp.key.location No (default: global) KMS Key Ring Location sac.sign.gcp.cache.jwks.seconds No (default: 3600) Length of time keys are cached sac.sign.gcp.cache.safety.multiple No (default: 24) Multiple of cache before key use"},{"location":"modules/sign/gcp/#key-rotation-and-caching-considerations","title":"Key Rotation and Caching Considerations","text":"<p>Public keys are retrieved from KMS and cached to avoid redundant API calls which may result in throttling. The default amount of time for caching is 1 hour, but this can be configured using <code>sac.sign.gcp.cache.jwks.seconds</code>.</p> <p>Due to this caching precautions must be taking when rotating keys. KMS's built in ability to create and delete keys is utilized allowing multiple keys to be active at a time. The problem arises when a new key is added, if it was immediately used for signing clients would not have the public key and would fail to verify it, therefore a period of time must elapse after it is created but before it can be used.</p> <p>This period of time is configured using the <code>sac.sign.gcp.cache.safety.multiple</code> which has a default of 24 and is multiplied by <code>sac.sign.gcp.cache.jwks.seconds</code> whose default of 1 hour means that new keys will not be used for 1 day after they are created. The exception to this is when only 1 key is available, it will be use regardless of when it was created.</p> <p>After this time elapses the key will be selected and used for signing and the older keys can be scheduled for deletion once any outstanding JWTs have also expired.</p> <p>This procedure allows for key rotations without a production impact as long as clients are configured to not cache the JWKS response for longer than this configured</p>"},{"location":"modules/sign/local/","title":"Sign - Local","text":"<p>The sign local module provides a local implementation of the sign interface so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/sign/local/#configuration","title":"Configuration","text":"<p>This module is enabled by setting the <code>SPRING_PROFILES_ACTIVE</code> to include the profile <code>sign-local</code>.</p> <p>The following environment variables are used by the sign local module:</p> Environment Variable Required Description sac.sign.local.active.kid Yes Active Key ID sac.sign.local.key1.privatekey Yes Key 1 Private Key sac.sign.local.key1.publickey Yes Key 1 Public Key sac.sign.local.key1.kid Yes Key 1 Key ID"},{"location":"modules/user/","title":"User","text":"<p>The user module provides the interfaces for authenticating users to the management API using different external OAuth 2.0 implementations.  Multiple user implementations can be enabled at the same time at runtime.</p>"},{"location":"modules/user/#user-interfaces","title":"User Interfaces","text":"<p>The following interfaces are implemented to provide data persistence.</p> <ul> <li><code>LoginUserService</code>: Interface for interacting with the user service for login</li> </ul>"},{"location":"modules/user/#user-implementations","title":"User Implementations","text":"<p>There are multiple user implementations that are available. Multiple user implementations can be enabled at runtime.</p> <ul> <li>User - GitHub: Login with a GitHub Account</li> <li>User - Google: Login with a Google Account</li> </ul>"},{"location":"modules/user/github/","title":"User - GitHub","text":"<p>The user GitHub module provides the implementation for the administrative console to authenticate users using GitHub OAuth 2.0.</p>"},{"location":"modules/user/github/#configuration","title":"Configuration","text":"Property Required Description sac.user.provider.github.clientid Yes The clientId for the GitHub application sac.user.provider.github.clientsecret Yes The clientSecret for the GitHub application"},{"location":"modules/user/google/","title":"User - Google","text":"<p>The user Google module provides the implementation for the administrative console to authenticate users using Google OAuth 2.0.</p>"},{"location":"modules/user/google/#configuration","title":"Configuration","text":"Property Required Description sac.user.provider.google.clientid Yes The clientId for the Google application sac.user.provider.google.clientsecret Yes The clientSecret for the Google application sac.token.url Yes The base URL for the token server which will end with \"/login/callback\" needed for Google's OAuth flow"},{"location":"modules/verify/","title":"Verify","text":"<p>The verify module provides the interfaces for verifying / validating the JWTs so that the underlying implementation can be swapped out as a runtime dependency.</p>"},{"location":"modules/verify/#verify-interfaces","title":"Verify Interfaces","text":"<p>The following interfaces are implemented to provide JWT and JWKS validation.</p> <ul> <li><code>JwksResolver</code>: Retrieve remote JWKs from another server.</li> <li><code>JwtVerifier</code>: Extract claims from JWT and verify JWT signature.</li> </ul>"},{"location":"modules/verify/#verify-implementations","title":"Verify Implementations","text":"<p>There is currently only one implementation for verify, but this is left as an integration point for future implementations. As such it is enabled by default.</p> <ul> <li>Verify - Auth0: A verify implementation that utilizes Auth0's Java library (this doesn't actually interact with Auth0)</li> </ul>"},{"location":"modules/verify/auth0/","title":"Verify - Auth0","text":"<p>The verify Auth0 module provides an implementation for verifying JWTs based on the Auth0 JWT library.</p>"},{"location":"modules/verify/auth0/#spring-boot-profile","title":"Spring Boot Profile","text":"<p>Given the less of a need to swap out the verify implementation, the verify implementation is enabled by default.</p>"},{"location":"setupguide/","title":"Setup Guide","text":"<p>ServiceAuthCentral is deployed as a set of Docker containers and a static website for the management portal. This guide will walk you through the steps to deploy the service. While the design of ServiceAuthCentral is modular and is intended to be extendable for deployment in a variety of environments, the initial version focuses on deployments to GCP.</p> <p>Note</p> <p>To get up and running read the deployment and configuration guides.</p>"},{"location":"setupguide/configuration/","title":"Configuration","text":"<p>The design principal behind ServiceAuthCentral is to be modular therefore there is some complexity to the configuration.  The guide here will walk through the minimal configuration needed to configure ServiceAuthCentral for running on GCP.</p>"},{"location":"setupguide/configuration/#token-api-configuration","title":"Token API Configuration","text":"<p>The token server requires the following environment variables to be set as a minimum viable deployment:</p> Environment Variable Description Example GOOGLE_CLOUD_PROJECT GCP Project Name <code>my-project-name</code> SPRING_PROFILES_ACTIVE Used to enable the modules <code>datamodel-firestore,sign-gcp</code> SAC_ISSUER The issuer URL used to identify the server <code>https://token.example.com</code> SAC_CORS_ORIGINS The comma separated list of Admin URLs to enable CORS <code>https://admin.example.com</code> SAC_USER_REDIRECTURI The comma separated list of redirector URLs for the admin portal https://admin.example.com/callback <p>The data model Firestore module requires the following environment variables to be set:</p> Environment Variable Description Example GOOGLE_CLOUD_PROJECT GCP Project Name <code>my-project-name</code> <p>This assumes the default collection names are used.</p> <p>The sign GCP module requires the following environment variables to be set:</p> Environment Variable Description Example GOOGLE_CLOUD_PROJECT GCP Project Nam e <code>my-project-name</code> SAC_SIGN_GCP_KEY_RING KMS Key Ring Name <code>serviceauthcentral-key-ring</code> SAC_SIGN_GCP_KEY_NAME KMS Key Name <code>serviceauthcentral-sign-key</code> <p>This assumes the keyring and key are in the global location.</p> <p>The admin console requires configing an external OAuth provider to authenticate users.</p> <p>The user GitHub module requires the following environment variables to be set:</p> Environment Variable Description Example SAC_USER_PROVIDER_GITHUB_CLIENTID The clientId provided by GitHub github-client-id SAC_USER_PROVIDER_GITHUB_CLIENTSECRET The clientSecret provided by GitHub github-client-secret <p>The user Google module requires the following environment variables to be set:</p> Environment Variable Description Example SAC_USER_PROVIDER_GOOGLE_CLIENTID The clientId provided by Google google-client-id SAC_USER_PROVIDER_GOOGLE_CLIENTSECRET The clientSecret provided by Google google-client-secret SAC_TOKEN_URL The base URL for the token server which will end with \"/login/callback\" needed for Google's OAuth flow https://token.example.com"},{"location":"setupguide/configuration/#manage-api-configuration","title":"Manage API Configuration","text":"<p>The manage server requires the following environment variables to be set as a minimum viable deployment:</p> Environment Variable Description Example SPRING_PROFILES_ACTIVE Used to enable the modules <code>datamodel-firestore</code> SAC_ISSUER The issuer URL used to identify the server <code>https://token.example.com</code> SAC_CORS_ORIGINS The comma separated list of Admin URLs to enable CORES <code>https://admin.example.com</code> <p>The data model Firestore module requires the following environment variables to be set:</p> Environment Variable Description Example GOOGLE_CLOUD_PROJECT GCP Project Name <code>my-project-name</code>"},{"location":"setupguide/configuration/#web-configuration","title":"Web Configuration","text":"<p>The serviceauthcentralweb requires the following variables to be configured for build and deploying:</p> Environment Variable Description VUE_APP_SAC_MANAGE_URI The \"/graphql\" URL for ServiceAuthCentral's manage server VUE_APP_SAC_REDIRECT_URI The \"/callback\" URL for serviceauthcentralweb VUE_APP_SAC_AUTHORIAZATION_ENDPOINT The \"/login/authorize\" URL for ServiceAuthCentral's token server VUE_APP_SAC_TOKEN_ENDPOINT The \"/v1/token\" URL for ServiceAuthCentral's token server VUE_APP_SAC_ISSUER The issuer configured for ServiceAuthCentral"},{"location":"setupguide/deployment/","title":"Deployment","text":"<p>Deploying ServiceAuthCentral is intended to be flexible having been built in a modular way. The following are the steps to deploy ServiceAuthCentral in the context of a GCP envirionment:</p>"},{"location":"setupguide/deployment/#prerequisites","title":"Prerequisites","text":"<p>ServiceAuthCentral has minimal external dependencies.  While it is possible for different data model implementations to be used, the default implementation uses Google Firestore.</p> <p>The Firestore database can be deployed using the OpenTofu module serviceauthcentral-firestore-gcp-tofu which will deploy the Firestore database itself, along with the necessary indexes and TTL configuration.  For multi-region deployments refer to the  high availability guide.</p> <p>Manual deployment of Firestore database with <code>gcloud</code></p> <pre><code># This example creates a Firestore database named 'serviceauthcentral' in the us-east4 region\n\n# Create Firestore database (if needed)\ngcloud firestore databases create \\\n  --database=\"serviceauthcentral\" \\\n  --location=\"us-east4\" \\\n  --type=\"firestore-native\"\n\n# Create Firestore Index for authorizations (audience ASC, subject ASC)\ngcloud firestore indexes composite create \\\n  --database=\"serviceauthcentral\" \\\n  --collection-group=\"authorizations\" \\\n  --field-config=\"field-path=audience,order=ASCENDING\" \\\n  --field-config=\"field-path=subject,order=ASCENDING\"\n\n# Create Firestore Index for authorizations (subject ASC, audience ASC)\ngcloud firestore indexes composite create \\\n  --database=\"serviceauthcentral\" \\\n  --collection-group=\"authorizations\" \\\n  --field-config=\"field-path=subject,order=ASCENDING\" \\\n  --field-config=\"field-path=audience,order=ASCENDING\"\n\n# Set TTL for 'keys' collection\ngcloud firestore fields ttls update ttl \\\n  --collection-group=\"keys\" \\\n  --database=\"serviceauthcentral\" \\\n  --enable-ttl\n\n# Set TTL for 'loginCodes' collection\ngcloud firestore fields ttls update ttl \\\n  --collection-group=\"loginCodes\" \\\n  --database=\"serviceauthcentral\" \\\n  --enable-ttl\n\n# Set TTL for 'loginStates' collection\ngcloud firestore fields ttls update ttl \\\n  --collection-group=\"loginStates\" \\\n  --database=\"serviceauthcentral\" \\\n  --enable-ttl\n</code></pre> <p>The KMS key ring and key are used for signing and verifying JWTs.  The key ring and key can be created using the OpenTofu module serviceauthcentral-kms-gcp-tofu. The recommendation here would be to use a global location for the key ring and key so it can be used in any region.</p> <p>In order to bootstrap the Firestore database with the necessary data, the OpenTofu moduleserviceauthcentral-firestore-bootstrap-gcp-tofu can be used to create the necessary record for the issuer and the authorization for the initial user to be able to log into the portal.</p> <p>Manual deployment of KMS keyring and signing key with <code>gcloud</code></p> <pre><code># Create the KMS key ring\ngcloud kms keyrings create \"serviceauthcentral-key-ring\" \\\n  --location=\"global\"\n\n# Create the KMS asymmetric signing key\ngcloud kms keys create \"serviceauthcentral-sign-key\" \\\n  --location=\"global\" \\\n  --keyring=\"serviceauthcentral-key-ring\" \\\n  --purpose=\"asymmetric-signing\" \\\n  --destroy-scheduled-duration=\"1d\" \\\n  --protection-level=\"software\" \\\n  --default-algorithm=\"rsa-sign-pkcs1-2048-sha256\" \\\n  --skip-initial-version-creation\n</code></pre>"},{"location":"setupguide/deployment/#deploying-serviceauthcentral-token-api","title":"Deploying ServiceAuthCentral Token API","text":"<p>The main data plane for ServiceAuthCentral is the Token API.  This API is responsible for issuing and validating JWTs.  The Token API can be deployed to GCP Cloud Run using the OpenTofu module serviceauthcentral-token-gcp-tofu.</p> <p>Alternatively the docker image can be deployed manually:</p> <p>Warning</p> <p>The below version deploys the 'dev' tag which is the latest development version. At this time there is no stable release.  See the latest releases on the GitHub releases page for the latest version.</p> <pre><code>docker pull ghcr.io/unitvectory-labs/serviceauthcentral-token:dev\n</code></pre> <p>The token server is configured using envirionment variables as outlined on the configuration guide.</p>"},{"location":"setupguide/deployment/#deploying-serviceauthcentral-manage-api","title":"Deploying ServiceAuthCentral Manage API","text":"<p>The control plane for ServiceAuthCentral is the Manage API.  This API is responsible for managing the clients and authorizations for ServiceAuthCentral through a GraphQL API.  The Manage API can be deployed to GCP Cloud Run using the OpenTofu module serviceauthcentral-manage-gcp-tofu.</p> <p>Alternatively the docker image can be deployed manually:</p> <p>Warning</p> <p>The below version deploys the 'dev' tag which is the latest development version. At this time there is no stable release.  See the latest releases on the GitHub releases page for the latest version.</p> <pre><code>docker pull ghcr.io/unitvectory-labs/serviceauthcentral-manage:dev\n</code></pre> <p>The manage server is configured using envirionment variables as outlined on the configuration guide.</p>"},{"location":"setupguide/deployment/#deploying-serviceauthcentral-web-portal","title":"Deploying ServiceAuthCentral Web Portal","text":"<p>The web portal for ServiceAuthCentral is a static website, serviceauthcentralweb, which can be deployed a variety of ways.</p> <p>The portal is a Vue 3 application that must be compiled with the appropriate <code>.env.production</code> configuration. The compiled static website can then be served.</p> <p>The web portal is configured using envirionment variables as outlined on the configuration guide.</p>"},{"location":"setupguide/highavailability/","title":"High Availability","text":"<p>The nature of being an OAuth 2.0 server that microservices depend on for authentication and authorization means that ServiceAuthCentral needs to be highly available. While for some deployments a single region may be sufficient, for others a multi-region deployment may be necessary.</p>"},{"location":"setupguide/highavailability/#multi-region-deployment-of-firestore","title":"Multi-Region Deployment of Firestore","text":"<p>The current datastore implemented by ServiceAuthCentral is Firestore. While Firestore offers a few multi-region locations this may not be sufficient for some deployments. This is where crossfiresync comes in. Crossfiresync is a tool that can be used to synchronize Firestore data between multiple regions in near real-time allowing for a multi-region deployment of Firestore. This is possible because ServiceAuthCentral is overwhelmingly a read-heavy application and Firestore is optimized for reads.</p> <p>Crossfiresync requires multiple components to be set up correctly including Pub/Sub topics and subscriptions and the application itself which facilitates the replication.  Therefore it is recommended to use the OpenTofu module crossfiresyncrun-tofu to set it manually.  The serviceauthcentral-gcp-tofu module which sets up a complete ServiceAuthCentral deployment includes the crossfiresyncrun-tofu module as a submodule and will set up crossfiresync for you as part of the recommended deployment.</p>"}]}